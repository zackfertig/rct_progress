name: Build portable binaries

# Ensure the workflow token can create/update releases
permissions:
  contents: write

on:
  workflow_dispatch: {}
  push:
    tags:
      - 'v*.*.*'

jobs:
  build:
    name: ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        python-version: ['3.11']

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install build deps (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Using Python from PATH:"
          python -c "import sys; print(sys.executable); print(sys.version)"
          python -m pip install --upgrade pip
          python -m pip install "pyinstaller==6.10.0"
          python -c "import sys, PyInstaller; print('Python:', sys.version); print('PyInstaller:', PyInstaller.__version__)"

      - name: Install build deps (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          echo "Using Python from PATH: $(command -v python)"
          python -c 'import sys; print(sys.executable); print(sys.version)'
          python -m pip install --upgrade pip
          python -m pip install "pyinstaller==6.10.0"
          python - << 'PY'
          import sys
          import PyInstaller
          print('Python:', sys.version)
          print('PyInstaller:', PyInstaller.__version__)
          PY

      - name: Build rct1-to-openrct2 (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          python -m PyInstaller --onefile --name rct1-to-openrct2 --paths src --hidden-import rct_progress.core src/rct_progress/highscores.py

      - name: Build rct1-to-openrct2 (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          python -m PyInstaller --onefile --name rct1-to-openrct2 --paths src --hidden-import rct_progress.core src/rct_progress/highscores.py

      - name: Build rct1-to-csv (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          python -m PyInstaller --onefile --name rct1-to-csv --paths src src/rct_progress/cli.py

      - name: Build rct1-to-csv (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          python -m PyInstaller --onefile --name rct1-to-csv --paths src src/rct_progress/cli.py

      - name: Build macOS .app droplet (drag-and-drop)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          # Build a GUI .app that accepts dropped files as argv
          python -m PyInstaller --windowed --name "RCT1 → OpenRCT2 Droplet" --paths src --hidden-import rct_progress.core src/rct_progress/highscores.py
          # Zip the .app bundle for distribution
          mkdir -p artifacts
          ARCH_RAW="$(uname -m)"
          case "$ARCH_RAW" in
            arm64) ARCH="arm64" ;;
            aarch64) ARCH="arm64" ;;
            x86_64) ARCH="x64" ;;
            amd64) ARCH="x64" ;;
            *) ARCH="$ARCH_RAW" ;;
          esac
          ditto -c -k --sequesterRsrc --keepParent "dist/RCT1 → OpenRCT2 Droplet.app" "artifacts/RCT1-to-OpenRCT2-Droplet-macos-$ARCH.zip"

      - name: Build Linux AppImage (drag-and-drop via .desktop %F)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          # Prepare AppDir structure
          APPDIR="AppDir"
          BIN="dist/rct1-to-openrct2"
          [ -f "$BIN" ] || { echo "Missing $BIN; PyInstaller build must have failed" >&2; exit 1; }
          rm -rf "$APPDIR"
          mkdir -p "$APPDIR/usr/bin" "$APPDIR/usr/share/applications" "$APPDIR/usr/share/icons/hicolor/256x256/apps"
          install -m 0755 "$BIN" "$APPDIR/usr/bin/rct1-to-openrct2"
          # AppRun launcher to forward args
          cat > "$APPDIR/AppRun" << 'EOF'
          #!/bin/sh
          HERE="$(dirname "$(readlink -f "$0")")"
          exec "$HERE/usr/bin/rct1-to-openrct2" "$@"
          EOF
          chmod +x "$APPDIR/AppRun"
          # Desktop entry (accept multiple files)
          cat > "$APPDIR/rct1-to-openrct2.desktop" << 'EOF'
          [Desktop Entry]
          Type=Application
          Name=RCT1 → OpenRCT2 (Highscores)
          Comment=Build or merge OpenRCT2 highscores.dat from RCT1 CSS0.DAT or CSV
          Exec=AppRun %F
          Icon=rct1-to-openrct2
          Terminal=false
          Categories=Game;Utility;
          EOF
          # Minimal placeholder icon (PNG) with ImageMagick; install if missing
          ICON_PATH="$APPDIR/usr/share/icons/hicolor/256x256/apps/rct1-to-openrct2.png"
          if ! command -v convert >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y imagemagick
          fi
          convert -size 256x256 xc:white -gravity center -pointsize 28 -fill black -annotate +0+0 "R1→O2" "$ICON_PATH"
          # Try linuxdeploy for dependency bundling; fallback to appimagetool if not available
          mkdir -p artifacts
          LINUXDEPLOY=linuxdeploy-x86_64.AppImage
          curl -fsSL -o "$LINUXDEPLOY" "https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/$LINUXDEPLOY" || true
          chmod +x "$LINUXDEPLOY" 2>/dev/null || true
          export APPIMAGE_EXTRACT_AND_RUN=1
          ARCH_RAW="$(uname -m)"
          case "$ARCH_RAW" in
            x86_64|amd64) ARCH=x64 ;;
            aarch64|arm64) ARCH=arm64 ;;
            *) ARCH="$ARCH_RAW" ;;
          esac
          if [ -x "$LINUXDEPLOY" ]; then
            # linuxdeploy expects .desktop and binary in place
            ./$LINUXDEPLOY --appdir "$APPDIR" -o appimage -i "$ICON_PATH" -d "$APPDIR/rct1-to-openrct2.desktop"
            # Robustly locate the generated AppImage (name is derived by appimagetool)
            mkdir -p artifacts
            APPIMG_OUT="$(ls -1 *.AppImage 2>/dev/null | head -n 1 || true)"
            if [ -z "$APPIMG_OUT" ]; then
              echo "No .AppImage produced in $(pwd). Contents:" >&2
              ls -la >&2 || true
              exit 1
            fi
            echo "Found AppImage: $APPIMG_OUT"
            mv "$APPIMG_OUT" "artifacts/RCT1-to-OpenRCT2-linux-$ARCH.AppImage"
          else
            # Fallback: appimagetool
            APPIMG_TOOL=appimagetool-x86_64.AppImage
            curl -fsSL -o "$APPIMG_TOOL" "https://github.com/AppImage/AppImageKit/releases/download/continuous/$APPIMG_TOOL"
            chmod +x "$APPIMG_TOOL"
            if [ ! -s "$APPIMG_TOOL" ]; then echo "appimagetool download failed (empty file)" >&2; exit 1; fi
            if head -c 10 "$APPIMG_TOOL" | grep -q "^<!DOCTYPE"; then echo "appimagetool download failed (HTML)" >&2; exit 1; fi
            ./$APPIMG_TOOL "$APPDIR" "artifacts/RCT1-to-OpenRCT2-linux-$ARCH.AppImage"
          fi
          # End AppImage build step

      - name: Prepare artifacts
        shell: bash
        run: |
          set -e
          mkdir -p artifacts
          # Determine platform and CPU architecture for artifact suffixes
          case "${{ runner.os }}" in
            Windows)
              PLATFORM=win
              ARCH_RAW="${PROCESSOR_ARCHITECTURE:-AMD64}"
              case "$ARCH_RAW" in
                AMD64|x86_64) ARCH=x64 ;;
                ARM64|aarch64) ARCH=arm64 ;;
                *) ARCH="$ARCH_RAW" ;;
              esac
              ;;
            Linux)
              PLATFORM=linux
              ARCH_RAW="$(uname -m)"
              case "$ARCH_RAW" in
                x86_64|amd64) ARCH=x64 ;;
                aarch64|arm64) ARCH=arm64 ;;
                *) ARCH="$ARCH_RAW" ;;
              esac
              ;;
            macOS)
              PLATFORM=macos
              ARCH_RAW="$(uname -m)"
              case "$ARCH_RAW" in
                x86_64|amd64) ARCH=x64 ;;
                arm64|aarch64) ARCH=arm64 ;;
                *) ARCH="$ARCH_RAW" ;;
              esac
              ;;
            *) PLATFORM=unknown; ARCH=unknown ;;
          esac
          echo "Platform: $PLATFORM"
          echo "Arch: $ARCH"
          for bin in rct1-to-openrct2 rct1-to-csv; do
            for path in dist/$bin*; do
              [ ! -e "$path" ] && continue
              fname="$(basename "$path")"
              name="$fname"; ext=""
              if [[ "$fname" == *.exe ]]; then
                ext=".exe"; name="${fname%.exe}"
              fi
              mv "$path" "artifacts/${name}-${PLATFORM}-${ARCH}${ext}"
            done
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rct_progress-${{ github.ref_name }}-${{ runner.os }}
          path: artifacts/*

  package:
    name: Build Python sdist+wheel
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install build backend
        run: |
          python -m pip install --upgrade pip
          python -m pip install build

      - name: Build sdist+wheel
        run: |
          python -m build

      - name: Upload dists
        uses: actions/upload-artifact@v4
        with:
          name: rct_progress-${{ github.ref_name }}-python-dists
          path: |
            dist/*.whl
            dist/*.tar.gz

  release:
    name: Attach to GitHub Release
    needs: [build, package]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./all-artifacts

      - name: Generate release notes from CHANGELOG.md
        shell: bash
        run: |
          set -euo pipefail
          TAG_NAME="${GITHUB_REF_NAME}"
          VERSION="${TAG_NAME#v}"
          echo "Preparing release notes for v$VERSION"
          # Extract the section for this version (from '## <version>' to the next '## ')
          awk -v ver="$VERSION" '
            $0 ~ "^## " ver {flag=1; next} 
            flag && /^## / {flag=0} 
            flag {print}
          ' CHANGELOG.md > .ch_section || true

          # Fallback if nothing was extracted
          if [ ! -s .ch_section ]; then
            echo "No dedicated section for v$VERSION found in CHANGELOG.md; using a generic note." >&2
            echo "See CHANGELOG.md for details." > .ch_section
          fi

          REPO="${GITHUB_REPOSITORY}"
          # Dynamically build download links from artifacts to support new arches (e.g., macos-arm64)
          WINDOWS_ITEMS=""
          MACOS_ITEMS=""
          LINUX_ITEMS=""
          OTHER_ITEMS=""
          while IFS= read -r -d '' f; do
            base="$(basename "$f")"
            url="https://github.com/$REPO/releases/download/$TAG_NAME/$base"
            case "$base" in
              *win-*.exe)
                if [[ "$base" == rct1-to-openrct2-* ]]; then
                  WINDOWS_ITEMS+="  - rct1-to-openrct2: $url\n"
                elif [[ "$base" == rct1-to-csv-* ]]; then
                  WINDOWS_ITEMS+="  - rct1-to-csv: $url\n"
                else
                  WINDOWS_ITEMS+="  - $base: $url\n"
                fi
                ;;
              RCT1-to-OpenRCT2-Droplet-macos-*.zip)
                MACOS_ITEMS+="  - rct1-to-openrct2 (.app droplet): $url\n"
                ;;
              *macos-*)
                if [[ "$base" == rct1-to-openrct2-* ]]; then
                  MACOS_ITEMS+="  - rct1-to-openrct2 (CLI one-file): $url\n"
                elif [[ "$base" == rct1-to-csv-* ]]; then
                  MACOS_ITEMS+="  - rct1-to-csv (CLI one-file): $url\n"
                else
                  MACOS_ITEMS+="  - $base: $url\n"
                fi
                ;;
              RCT1-to-OpenRCT2-linux-*.AppImage)
                LINUX_ITEMS+="  - rct1-to-openrct2 (AppImage): $url\n"
                ;;
              *linux-*)
                if [[ "$base" == rct1-to-openrct2-* ]]; then
                  LINUX_ITEMS+="  - rct1-to-openrct2 (CLI one-file): $url\n"
                elif [[ "$base" == rct1-to-csv-* ]]; then
                  LINUX_ITEMS+="  - rct1-to-csv (CLI one-file): $url\n"
                else
                  LINUX_ITEMS+="  - $base: $url\n"
                fi
                ;;
              *)
                OTHER_ITEMS+="  - $base: $url\n"
                ;;
            esac
          done < <(find all-artifacts -type f -print0 2>/dev/null || true)

          {
            echo "What's new in v$VERSION"
            echo
            cat .ch_section
            echo
            echo "Downloads"
            if [ -n "$WINDOWS_ITEMS" ]; then
              echo "- Windows"
              printf "%b" "$WINDOWS_ITEMS"
            fi
            if [ -n "$MACOS_ITEMS" ]; then
              echo "- macOS"
              printf "%b" "$MACOS_ITEMS"
            fi
            if [ -n "$LINUX_ITEMS" ]; then
              echo "- Linux"
              printf "%b" "$LINUX_ITEMS"
            fi
            if [ -n "$OTHER_ITEMS" ]; then
              echo "- Other"
              printf "%b" "$OTHER_ITEMS"
            fi
          } > release_notes.md

      - name: Create/Update GitHub Release
        uses: ncipollo/release-action@v1
        with:
          token: ${{ github.token }}
          tag: ${{ github.ref_name }}
          name: rct_progress ${{ github.ref_name }}
          bodyFile: release_notes.md
          draft: false
          prerelease: false
          allowUpdates: true
          makeLatest: true
          removeArtifacts: false
          artifactContentType: application/octet-stream
          artifacts: |
            all-artifacts/**
